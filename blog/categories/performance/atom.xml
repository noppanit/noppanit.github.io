<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: performance | My Blog]]></title>
  <link href="https://www.noppanit.com/blog/categories/performance/atom.xml" rel="self"/>
  <link href="https://www.noppanit.com/"/>
  <updated>2016-02-18T19:43:56-05:00</updated>
  <id>https://www.noppanit.com/</id>
  <author>
    <name><![CDATA[Noppanit Charassinvichai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gatling Cluster]]></title>
    <link href="https://www.noppanit.com/gatling-cluster/"/>
    <updated>2016-02-17T20:28:25-05:00</updated>
    <id>https://www.noppanit.com/gatling-cluster</id>
    <content type="html"><![CDATA[<h3 id="performance-matters">Performance matters</h3>
<p>I think we can all agree that performance is one of the most important things in any application. That’s why we have performance or load testing. There’s a lot of tools out there we can choose from. But for this tutorial I pick <a href="http://gatling.io/#/">Gatling</a>.</p>

<p>Now it’s easy to say I want to generate 1,000,000 requests and hit the machine as hard as possible. In reality, your machine won’t be able to do that due to OS or Network Card limitations. The most common thing is <code>ulimit</code></p>

<p>Gatling has a way to <a href="http://gatling.io/docs/1.5.6/user_documentation/cookbooks/scaling_out.html">scale out</a> the test scenario to different machines but there’s not enough documentation on the website.</p>

<p>Credit goes to <a href="http://www.nimrodstech.com/gatling-cluster-load-testing/">nimrodtech</a> for creating the script but I adapted a bit so if anybody wants to grab this please feel free.</p>

<p>My version assumes that you’re using EC2 instance and the directory structures are different between the host and local.</p>

<p>```
#Assuming same user name for all hosts
USER_NAME=’ubuntu’</p>

<h1 id="remote-hosts-list">Remote hosts list</h1>
<p>HOSTS=( IP_ADDRESSES )
PEM_FILE=~/.ssh/your_pem.pem</p>

<h1 id="you-should-change-all-of-this-values-to-suit-your-structure">You should change all of this values to suit your structure</h1>
<p>CURRENT_DIRECTORY=$(pwd)
GATLING_LOCAL_HOME=$CURRENT_DIRECTORY/performance/gatling
GATLING_REMOTE_HOME=/home/ubuntu/gatling</p>

<p>GATLING_LOCAL_SIMULATIONS_DIR=$GATLING_LOCAL_HOME/user-files/simulations/
GATLING_REMOTE_SIMULATIONS_DIR=$GATLING_REMOTE_HOME/user-files/simulations/</p>

<p>GATLING_LOCAL_RUNNER=$GATLING_LOCAL_HOME/bin/gatling.sh
GATLING_REMOTE_RUNNER=$GATLING_REMOTE_HOME/bin/gatling.sh</p>

<h1 id="change-to-your-simulation-class-name">Change to your simulation class name</h1>
<p>SIMULATION_NAME=’YOUR_SIMULATION’</p>

<h1 id="no-need-to-change-this">No need to change this</h1>
<p>GATLING_LOCAL_REPORT_DIR=$GATLING_LOCAL_HOME/results/
GATLING_REMOTE_REPORT_DIR=$GATLING_REMOTE_HOME/results/</p>

<p>GATHER_REPORTS_DIR=~/Downloads/reports/</p>

<p>echo “Starting Gatling cluster run for simulation: $SIMULATION_NAME”</p>

<p>echo “Cleaning previous runs from localhost”
rm -rf $GATLING_LOCAL_REPORT_DIR
mkdir $GATLING_LOCAL_REPORT_DIR
rm -rf $GATLING_LOCAL_REPORT_DIR</p>

<p>rm -rf $GATHER_REPORTS_DIR
mkdir -p $GATHER_REPORTS_DIR</p>

<p>for HOST in “${HOSTS[@]}”
do
  echo “Cleaning previous runs from host: $HOST”
  ssh -i $PEM_FILE -n -f $USER_NAME@$HOST “sh -c ‘rm -rf $GATLING_REMOTE_REPORT_DIR’”
done</p>

<p>for HOST in “${HOSTS[@]}”
do
  echo “Copying simulations to host: $HOST”
  scp -i $PEM_FILE -r $GATLING_LOCAL_SIMULATIONS_DIR/* $USER_NAME@$HOST:$GATLING_REMOTE_SIMULATIONS_DIR
done</p>

<p>for HOST in “${HOSTS[@]}”
do
  echo “Running simulation on host: $HOST”
  ssh -i $PEM_FILE -n -f $USER_NAME@$HOST “sh -c ‘nohup $GATLING_REMOTE_RUNNER -nr -s $SIMULATION_NAME &gt; $GATLING_REMOTE_HOME/run.log 2&gt;&amp;1 &amp;’”
done</p>

<p>echo “Running simulation on localhost”
$GATLING_LOCAL_RUNNER -nr -s $SIMULATION_NAME</p>

<p>echo “Gathering result file from localhost”
ls -t $GATLING_LOCAL_REPORT_DIR | head -n 1 | xargs -I {} mv ${GATLING_LOCAL_REPORT_DIR}{} ${GATLING_LOCAL_REPORT_DIR}report
cp ${GATLING_LOCAL_REPORT_DIR}report/simulation.log $GATHER_REPORTS_DIR</p>

<p>for HOST in “${HOSTS[@]}”
do
  echo “Gathering result file from host: $HOST”
  ssh -i $PEM_FILE -n -f $USER_NAME@$HOST “sh -c ‘ls -t $GATLING_REMOTE_REPORT_DIR | head -n 1 | xargs -I {} mv ${GATLING_REMOTE_REPORT_DIR}{} ${GATLING_REMOTE_REPORT_DIR}report’”
  scp -i $PEM_FILE $USER_NAME@$HOST:${GATLING_REMOTE_REPORT_DIR}report/simulation.log ${GATHER_REPORTS_DIR}simulation-$HOST.log
done</p>

<p>mv $GATHER_REPORTS_DIR $GATLING_LOCAL_REPORT_DIR
echo “Aggregating simulations”
$GATLING_LOCAL_RUNNER -ro reports</p>

<h1 id="using-macosx">using macOSX</h1>
<p>open ${GATLING_LOCAL_REPORT_DIR}reports/index.html
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why algorithm matters?]]></title>
    <link href="https://www.noppanit.com/why-algorithm-matters/"/>
    <updated>2015-10-08T15:55:29-04:00</updated>
    <id>https://www.noppanit.com/why-algorithm-matters</id>
    <content type="html"><![CDATA[<p>If you have been to one of those technical interviews, you will like this.</p>

<blockquote class="twitter-tweet" lang="en"><p lang="en" dir="ltr">Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</p>&mdash; Max Howell (@mxcl) <a href="https://twitter.com/mxcl/status/608682016205344768">June 10, 2015</a></blockquote>
<script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>I’m not going to rant about how broken the technical interviews are. There’s enough people who are more qualified to rant about this more than me.</p>

<p>So, why this matters? I just want to give a quick example of why algorithm matters. Please no haters! I know some of you might read this and will say “I do that all the time, what’s the big deal”. I’m still a bad developer and I’m still learning.</p>

<h2 id="scenario">Scenario</h2>

<p>You are a general, your home country is at war and you have to fight for your country. You are given a group of soldiers. You want to come up with a strategy to win the battle. Here’s the example of the soldiers.</p>

<p>```</p>

<p>[
    {
        “category”: “machine-gun”,
        “id”: 0,
        “name”: “D408CF”
    },
    {
        “category”: “machine-gun”,
        “id”: 1,
        “name”: “C0BAD7”
    },
    {
        “category”: “rocket-man”,
        “id”: 2,
        “name”: “04B5E4”
    },
    {
        “category”: “rocket-man”,
        “id”: 3,
        “name”: “22F3CF”
    },
    {
        “category”: “machine-gun”,
        “id”: 4,
        “name”: “811E8A”
    }
    ,
    …
]</p>

<p>```</p>

<p>You came out of a high-profile meeting and all the generals agree that this formation will be best to fight the enemy; <em>infantry</em>, <em>machine-gun</em> and <em>rocket-man</em>. How can I rearrange this quick enough because we’re going to attack tomorrow? Simple I go ahead and write the code.</p>

<p>First, let’s generate a bunch of soldiers</p>

<p>``` python</p>

<p>class Soldier(object):
    def <strong>init</strong>(self, id, name, category):
        self.id = id
        self.name = name
        self.category = category</p>

<p>number_of_soldier = 10000</p>

<p>soldiers = []
for i in range(0, number_of_soldier):
    name = str(uuid.uuid4().get_hex().upper()[0:6])
    soldiers.append(Soldier(i, name, random.choice(categories)))</p>

<p>```</p>

<p>Then let’s rearrange them.</p>

<p>``` python</p>

<p>import json
import uuid
import random
import time</p>

<p>categories = [‘infantry’, ‘machine-gun’, ‘rocket-man’]</p>

<p>start = time.time()
result = []
for c in categories:
    s_list = []
    for s in soldiers:
        if s.category == c:
            s_list.append(s)</p>

<pre><code>result.extend(s_list)
s_list = []
</code></pre>

<p>end = time.time()
print(end - start)</p>

<p>```</p>

<p>It works, but you’re too late you can’t form the soldiers in time. If you take a closer look, this algorithm takes <em>O(n</em>m)* for the time complexity given the number of soldiers is <em>n</em> and the <em>category</em> is <em>m</em>. If you have a million soldiers and a million categories you would get <em>O(n^2)</em>. How can we make this one faster?</p>

<p>Here’s my second version. Hmm, rearrange into category… category is bucket. How about using map?</p>

<p>``` python</p>

<p>from collections import defaultdict</p>

<p>start = time.time()
map_of_soldiers = defaultdict(list)</p>

<p>for s in soldiers:
    map_of_soldiers[s.category].append(s)</p>

<p>result = []
for c in categories:
    result.extend(map_of_soldiers.get(c))</p>

<p>end = time.time()
print(end - start)</p>

<p>```</p>

<p>This is the time difference of those two algorithms.</p>

<p>```</p>

<p>0.00743103027344
0.00331783294678</p>

<p>```</p>

<p>By just changing the data structure, you can see that the <em>map</em> version is almost twice as fast. I hope I can demostrate how choosing the right algorithm matters in your program.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress on crack]]></title>
    <link href="https://www.noppanit.com/octopress-on-crack/"/>
    <updated>2015-10-07T22:44:22-04:00</updated>
    <id>https://www.noppanit.com/octopress-on-crack</id>
    <content type="html"><![CDATA[<p>I believe you will find a ton of blogs writing about makeing Octopress faster. I believe nearly everyone who migrated their blog to Octopress, the first post would be the migration and the next would be performance tuning. I want to be the cool kid so here you go.</p>

<p>Once you got out of WordPress now there’s much more you can do about your performance. But before you start, nothing can be done before you have the baseline numbers</p>

<h2 id="before">Before</h2>

<p>Here’s my before performance from Google PageSpeed.</p>

<p><img src="/wp-content/uploads/2015/10/google-pagespeed-before.jpg" title="Google PageSpeed before performance" ></p>

<p>And from webpagetest.org</p>

<p><img src="/wp-content/uploads/2015/10/before-perf-noppanit-com.jpg" title="Webpagetest before performance" ></p>

<p>In a nutshell, my page starts to render in <em>2.4s</em> and finishes in <em>4s</em>. Yikes! I wouldn’t even want to wait for my site to load. Let’s see where’s the lowest hanging fruit.</p>

<h2 id="what-about-images">What about images?</h2>

<p>A picture is worth a thousand words. Who doesn’t like image right? Also, I tend to have a lot of screenshots and they’re all PNGs. And they tend to be big. As they’re all screenshots so I don’t really care about losing some of the quality so I convert them to be jpg. If you’re using OSX, there’s a command that you can run.</p>

<p><code>
sips -s format jpeg your_png.png --out your_pic.jpg
</code></p>

<p>Now what can we do to reduce the size? There’s lots of tools out there that you can just throw your image in and it will compress the image for you. I use <a href="https://compressor.io/">compressor.io</a>. It’s really good. Just try throwing your image in there and see what happens. Compressor.io can reduce my images up to 60% and that saves a lot of bandwidth.</p>

<h2 id="minify-cssjs">Minify CSS/JS</h2>

<p>Fortunetely, I use <a href="https://www.cloudflare.com/">Cloudflare</a> and they have the feature to minify that for you. So, I just flipped the switch and it works like magic.</p>

<h2 id="browser-caching">Browser caching</h2>

<p>Going back to what Google PageSpeed tells us again. It complaints about <em>Leverage browser caching</em>. I’m lucky again because in Cloudflare you can set the cache to be 30 days and that seems to be ok for Google.</p>

<h2 id="inline-css">Inline CSS</h2>

<p>I use <a href="https://github.com/tommy351/Octopress-Theme-Slash">Slash</a> theme and when I look at the CSS, it’s only 22K. So why not just inline it and save one more request for the browser. So, in <em>_includes/head.html</em> you can change the line that includes your stylesheet to be.</p>

<p><figure class='code'><figcaption><span>html </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;style>
</span><span class='line'>		{\% include screen.css %} # delete '\' in front of % before you paste this snippet
</span><span class='line'>	&lt;/style></span></code></pre></td></tr></table></div></figure></p>

<p>This might be different from theme to theme but it shouldn’t be difficult to find that out.</p>

<h2 id="after">After</h2>

<p>Now, let’s have a quick look at the after performance.</p>

<p>Here’s my after performance from Google PageSpeed.</p>

<p><img src="/wp-content/uploads/2015/10/google-pagespeed-after.jpg" title="Google PageSpeed after" ></p>

<p>It’s a lot better now but there’s one tiny problem with mobile which I’ll write another blog post about that.</p>

<p>Let’s have a look at webpagetest now.</p>

<p><img src="/wp-content/uploads/2015/10/webpagetest-after.jpg" title="Webpagetest After" ></p>

<p>A lot better! It’s still not the best but now my page loads within <em>0.5s</em> and finishes in <em>1.9s</em>. However, there’s still a lot to work on mobile.</p>

<p>I could shead about 200ms by not using SSL but I’m willing to compromise that with a little bit of security.</p>

<h2 id="whats-next">What’s next</h2>

<p>I’d like to try hosting the images on S3 to see if that would speed up the load time. And I want to make the images responsive for mobile.</p>

]]></content>
  </entry>
  
</feed>
