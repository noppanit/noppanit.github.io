<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | My Blog]]></title>
  <link href="https://www.noppanit.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="https://www.noppanit.com/"/>
  <updated>2015-12-30T21:00:35-05:00</updated>
  <id>https://www.noppanit.com/</id>
  <author>
    <name><![CDATA[Noppanit Charassinvichai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Example: How did I convert async code to sync code with Promise.]]></title>
    <link href="https://www.noppanit.com/example-how-did-i-convert-async-code-to-sync-code-with-promise/"/>
    <updated>2015-05-24T00:00:00-04:00</updated>
    <id>https://www.noppanit.com/example-how-did-i-convert-async-code-to-sync-code-with-promise</id>
    <content type="html"><![CDATA[<p>I’ve just finished my first refactor to convert my node.js code to be more promisey (I believe that’s the word they use these days). There’s lots of documents out there to do this. However, I thought I should contribute more to help me understand more and might get some feedback from people who’s seen it as well.</p>

<p>I’m trying to create a bot to report me back the performance of my site in desktop and mobile mode. So, I thought it would be easy since Google has an <a href="https://developers.google.com/speed/docs/insights/v2/getting-started">API</a> for that already so I went ahead and did this.</p>

<p>``` javascript</p>

<p>var request = require(‘request’);
var urlToGetTheScore = ‘https://www.googleapis.com/pagespeedonline/v2/runPagespeed?url=http://www.noppanit.com&amp;strategy=desktop&amp;fields=ruleGroups’</p>

<p>request.get(urlToGetTheScore, function (error, response, body) {
  if(error) console.log(error);</p>

<p>console.log(JSON.parse(body).ruleGroups.SPEED.score);
});</p>

<p>```</p>

<p>It’s pretty easy and straight forward right but now that would only return the score of desktop. I need the score of my mobile site as well. So, I added more code to be like this.</p>

<p>``` javascript</p>

<p>var request = require(‘request’);</p>

<p>var urlToGetTheScoreDesktop = ‘https://www.googleapis.com/pagespeedonline/v2/runPagespeed?url=http://www.noppanit.com&amp;strategy=desktop&amp;fields=ruleGroups’</p>

<p>var urlToGetTheScoreMobile = ‘https://www.googleapis.com/pagespeedonline/v2/runPagespeed?url=http://www.noppanit.com&amp;strategy=mobile&amp;fields=ruleGroups’</p>

<p>request.get(urlToGetTheScoreDesktop, function (error, response, body) {
  if(error) console.log(error);</p>

<p>console.log(JSON.parse(body).ruleGroups.SPEED.score);
});</p>

<p>request.get(urlToGetTheScoreMobile, function (error, response, body) {
  if(error) console.log(error);</p>

<p>console.log(JSON.parse(body).ruleGroups.SPEED.score);
});</p>

<p>```</p>

<p>That’s great but I want to return both scores to a client so I can report the scores rather than printing them to the console. Since, <strong>request</strong> is asynchronous you cannot guarantee which score would come first. So, I thought it’s easy. I just need to call one request after the other. So, I came up with this.</p>

<p>``` javascript</p>

<p>var request = require(‘request’);</p>

<p>var urlToGetTheScoreDesktop = ‘https://www.googleapis.com/pagespeedonline/v2/runPagespeed?url=http://www.noppanit.com&amp;strategy=desktop&amp;fields=ruleGroups’</p>

<p>var urlToGetTheScoreMobile = ‘https://www.googleapis.com/pagespeedonline/v2/runPagespeed?url=http://www.noppanit.com&amp;strategy=mobile&amp;fields=ruleGroups’</p>

<p>request.get(urlToGetTheScoreDesktop, function (error, response, body) {
  if(error) reject(error);</p>

<p>var desktopScore = JSON.parse(body).ruleGroups.SPEED.score;</p>

<p>request.get(urlToGetTheScoreMobile, function (error, response, body) {
    if(error) reject(error);</p>

<pre><code>var mobileScore = JSON.parse(body).ruleGroups.SPEED.score;

console.log('desktop score is ' + desktopScore + ' and mobile score is ' + mobileScore);   }); });
</code></pre>

<p>```</p>

<p>Look at how ugly it is. Now I want to make it prettier. So, I will use Promise to make it look nicer. As a good engineer I need to create a test first.</p>

<p>``` javascript</p>

<p>var perfModule = require(‘./pagespeed’),
sinon = require(‘sinon’),
request = require(‘request’),
expect = require(‘expect.js’);</p>

<p>describe(‘Performance’, function() {
var server;
  beforeEach(function(done) {
    sinon.stub(request, ‘get’).yields(null, null, JSON.stringify({ruleGroups : { SPEED: {score:10}} }));
    done();
  });</p>

<p>it(‘should send performance stats to chat room’, function(done) {
    perfModule.pagespeed(function(donotknow, msg) {
      done();
      expect(msg).to.eql(‘desktop speed is 10 and mobile speed is 10’);
    });
  });
});</p>

<p>```</p>

<p>I’m using <a href="http://sinonjs.org/">Sinon.js</a> as the mocking framework and <a href="http://mochajs.org/">Mocha</a> as the testing framework which are pretty standard.</p>

<p>Now I can start refactor my code. At first, I wrote some code like this, just to make it work.</p>

<p>``` javascript</p>

<p>var request = require(‘request’);</p>

<p>var getSpeed = function(strategy) {
  var url = ‘https://www.googleapis.com/pagespeedonline/v2/runPagespeed?url=http://www.noppanit.com&amp;strategy=’+ strategy + ‘&amp;fields=ruleGroups’
  return new Promise(function(resolve, reject) {
    request.get(url, function (error, response, body) {
      if(error) reject(error);</p>

<pre><code>  console.log(body);
  resolve(JSON.parse(body).ruleGroups.SPEED.score);
});   }); };
</code></pre>

<p>var pagespeed = function(cb) {
  getSpeed(‘desktop’).then(function(desktopSpeed) {
    getSpeed(‘mobile’).then(function(mobileSpeed) {
      console.log(‘desktop speed is ‘ + desktopSpeed + ‘ and mobile speed is ‘ + mobileSpeed);
    });</p>

<p>});
};</p>

<p>exports.pagespeed = pagespeed;</p>

<p>```</p>

<p>Any good JavaScript developer would be like, WTH!. You still have callbacks. I thought Promise would solve that issue already! Now, I could use the power of <strong>Promise.all</strong> which takes array of promises and return array of results. My final code would look something like this.</p>

<p>``` javascript</p>

<p>var request = require(‘request’),
Promise = require(‘promise’);</p>

<p>var getSpeed = function(strategy) {
  var url = ‘https://www.googleapis.com/pagespeedonline/v2/runPagespeed?url=http%3A%2F%2Ffusion.net&amp;strategy=’+ strategy + ‘&amp;fields=ruleGroups’
  return new Promise(function(resolve, reject) {
    request.get(url, function (error, response, body) {
      if(error) reject(error);</p>

<pre><code>  console.log(body);
  resolve(JSON.parse(body).ruleGroups.SPEED.score);
});   }); };
</code></pre>

<p>var pagespeed = function(cb) {
  Promise.all([getSpeed(‘desktop’), getSpeed(‘mobile’)]).then(function(speed) {
    var desktop = speed[0];
    var mobile = speed<a href="https://developers.google.com/speed/docs/insights/v2/getting-started">1</a>;</p>

<pre><code>console.log(null, 'desktop speed is ' + desktop + ' and mobile speed is ' + mobile);   }).catch(function(error) {
console.log(error);   }); };
</code></pre>

<p>exports.pagespeed = pagespeed;</p>

<p>```</p>

<p>I’m not an expert in Promise and I welcome any feedback that would help improve my code.</p>

<p>Reference<br />
<a href="http://www.html5rocks.com/en/tutorials/es6/promises/">ES6 Promises</a><br />
<a href="http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html">We have a problem with promises</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event delegation in JavaScript is fast but how fast?]]></title>
    <link href="https://www.noppanit.com/event-delegation-javascript-fast-fast/"/>
    <updated>2014-11-22T00:00:00-05:00</updated>
    <id>https://www.noppanit.com/event-delegation-javascript-fast-fast</id>
    <content type="html"><![CDATA[<p>People say always use event delegation for adding event because it’s faster. But how fast exactly? I really want to create a test case for this, but I couldn’t figure out how to run B[enchmark.js][1] in browser. So, I thought we could just use Chrome Developer Tool to achieve this.</p>

<h2 id="what-are-we-measuring">What are we measuring?</h2>

<p>As I said in the beginning, we want to know how fast event delegation is compared to direct binding that most people do. For example, I’ve always seen people do this</p>

<p><code>javascript
$('#ul li').on('click', function() {
  // doing something amazing.
});
</code></p>

<p>What is actually doing is, jQuery will add the event to each of the <strong>li</strong> in the DOM. If you have 3-4 lis, then I don’t think it’s going to make a big difference. However, if you have a thousand lis, you will see some difference. I’ll show you by using Chrome Developer Tool.</p>

<h2 id="what-do-we-need">What do we need?</h2>

<p>We need some basic HTML</p>

<p>It’s going to be something like this</p>

<p>``` html</p>
<ul id="parent">
  <li></li>
  // 999 more <li>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>Then we will have JavaScript like this
</span></code></pre></td></tr></table></div></figure> html
<script src="https://code.jquery.com/jquery-1.11.1.min.js"></script>
<script>
    $('#parent li').on('click', function() {
        console.log('you clicked me!');
    });

</script>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>If you open your html page on Chrome you should see something like this.  
</span><span class='line'><img src="https://www.noppanit.com/wp-content/uploads/2014/11/Screen-Shot-2014-11-21-at-7.06.19-PM.png">
</span><span class='line'>
</span><span class='line'>If you go down to where JavaScript is executed You will see it takes around **37ms** to execute the snippet.  
</span><span class='line'>
</span><span class='line'><img src="https://www.noppanit.com/wp-content/uploads/2014/11/Screen-Shot-2014-11-21-at-7.07.18-PM.png">
</span><span class='line'>
</span><span class='line'>Now change your snippet to be event delegation
</span></code></pre></td></tr></table></div></figure> html
<script src="https://code.jquery.com/jquery-1.11.1.min.js"></script>
<script>
    $('#parent').on('click', 'li', function() {
        console.log('you clicked me!');
    });

</script>
```

And refresh the page you should see something like this.  

<img src="https://www.noppanit.com/wp-content/uploads/2014/11/Screen-Shot-2014-11-21-at-7.12.02-PM.png">

Now it will only take **2ms** to execute the snippet. It&#8217;s because the event is added to one element not 1000 of them. 

This is just an easy example that you can do it yourself to improve your performance.

 [1]: http://benchmarkjs.com/ "benchmark.js"
 [2]: https://www.noppanit.com/wp-content/uploads/2014/11/Screen-Shot-2014-11-21-at-7.06.19-PM.png
 [3]: https://www.noppanit.com/wp-content/uploads/2014/11/Screen-Shot-2014-11-21-at-7.07.18-PM.png
 [4]: https://www.noppanit.com/wp-content/uploads/2014/11/Screen-Shot-2014-11-21-at-7.12.02-PM.png
</li></ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Knockout.js virtual elements are being stripped out from mobile.]]></title>
    <link href="https://www.noppanit.com/knockout-js-virtual-elements-stripped-mobile/"/>
    <updated>2014-10-07T00:00:00-04:00</updated>
    <id>https://www.noppanit.com/knockout-js-virtual-elements-stripped-mobile</id>
    <content type="html"><![CDATA[<p>This rarely happens and you would be surprised what is the cause of this. Recently, I have just finished a mobile site using knockout.js. I have used a fair amount of Virtual Elements in Knockout.js. But weirdly enough one day my Manager came in and talk to my <a href="https://twitter.com/sragu" title="Srini">tech lead</a> (@sragu) that the site is not working. We quickly checked with our live site and everything was ok yet the site from his phone wasn’t working at all.</p>

<p>We spent quite a long time to find out the cause of this. We cleared the cache. We restarted the phone. Tried different browsers. Luckily, then we found out this <a href="http://stackoverflow.com/questions/4113268/how-to-stop-javascript-injection-from-vodafone-proxy">thread</a> from Stackoverflow.com.</p>

<p>The cause of this is that Vodafone corporate network stripped out HTML comments to save and optimise the bandwidth.</p>

<p>The solution is to set Cache-Control to no-transform and the problem solved. If you have the same problem as me then this is the solution.</p>

<p><code>
Cache-Control: no-transform
</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Contextual Preloading for Ajax request.]]></title>
    <link href="https://www.noppanit.com/contextual-preloading-ajax-request/"/>
    <updated>2014-05-10T00:00:00-04:00</updated>
    <id>https://www.noppanit.com/contextual-preloading-ajax-request</id>
    <content type="html"><![CDATA[<p>I have just heard this from my friend <a href="https://twitter.com/rajveerr" title="rajveerr twitter">@rajveerr</a> about pre-loading at the global level, this concept is not new but I have just learned it.. Usually and I think everyone has done it before. People would do something like this.</p>

<p><code>javascript
$('#link1').on('click', function (e) {
    // Do some funky spinning wheel
    $.ajax({
        url: '/echo/json',
        success : function (data) {
            // Cancel that funky spinning wheel
        }
    });
});
</code></p>

<p>And you have to do this for every single ajax request. So, here’s how you would do that in a contextual level.</p>

<iframe width="100%" height="300" src="//jsfiddle.net/noppanit/y63n5/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>The trick is that in each ajax request you need to add context option. I used zepto as an example but jquery should work the same. The reason is that is <strong>e.target</strong> behaves differently each browser. Also, usually Ajax request would be fired from <strong>#document</strong> level that means your <strong>e.target</strong> would be your &lt;/p&gt;</p>

<p><code>javascript
$('#link1').on('click', function (e) {
    $.ajax({
        url: '/echo/json',
        &lt;strong&gt;context: e.target&lt;/strong&gt;,
        success : function (data) {
            console.log(data);
        }
    });
});
</code></p>

<p>By doing this if you want your pre-loader you just need to add <strong>.ajaxContainer</strong> class to your container.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Example of Require.js optimizer.]]></title>
    <link href="https://www.noppanit.com/example-require-js-optimizer/"/>
    <updated>2014-02-09T00:00:00-05:00</updated>
    <id>https://www.noppanit.com/example-require-js-optimizer</id>
    <content type="html"><![CDATA[<p>I decided to write this blog post to show how easy it is to setup require.js optimizer and how many bytes it saves.</p>

<p>To make it as simple as possible, I created this repository on <a href="https://github.com/noppanit/requirejs-optimization-example" title="Require.js optimisation example">github</a> to show the real example.</p>

<p>This is the results of optimisation.</p>

<p><img src="http://www.noppanit.com/wp-content/uploads/2014/02/Screen-Shot-2014-02-09-at-19.45.38.png"></p>

<p>And this is the result of non-optimized version.</p>

<p><img src="http://www.noppanit.com/wp-content/uploads/2014/02/Screen-Shot-2014-02-09-at-19.46.59.png"></p>

<p>It’s clear to see that the optimized version takes shorter to load the script, where as the non-optimized version in the files might be smaller but with a lot of calls, it takes longer to load all the scripts.</p>

]]></content>
  </entry>
  
</feed>
